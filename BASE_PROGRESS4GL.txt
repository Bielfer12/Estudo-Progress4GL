- DEFINIÇÃO DE VARIVAVEIS: 

//declaração de variaveis 
DEF VAR iInteiro AS INT.
DEF VAR dDecimal AS DEC FORMAT ">>,>>>,>>9.99".
DEF VAR cChar    AS CHAR.
DEF VAR lgChar   AS LONGCHAR.
DEF VAR lBollean AS LOGICAL INITIAL YES.
DEF VAR dDate    AS DATE.
DEF VAR dtDateTime AS DATETIME.
DEF VAR aArray   AS INT EXTENT 4.

dDate = TODAY.
dtDateTime = NOW.

dDecimal = 1234.999.

MESSAGE DAY(dDate)  SKIP 
        MONTH(dDate)SKIP
        YEAR(dDate) VIEW-AS ALERT-BOX TITLE "Data".
MESSAGE dtDateTime VIEW-AS ALERT-BOX TITLE "Data/tempo".
MESSAGE ddecimal VIEW-AS ALERT-BOX TITLE "Decimal".  

//MESSAGE - MOSTRA COMO O DADO ESTA SALVO EM MEMORIA
//VIEW-AS - VER COMO SETANDO COMO VAI FICAR O RESULTADO
//ALERT   - BOX - CAIXA DE AVISO 
//TITLE   - SETA O TITULO DA BOX 

- CONTROLADORES ARITMETICOS/RELACIONAIS:

DEF VAR iNum  AS INT INITIAL 10.
DEF VAR iNum2 AS INT INITIAL 5.

*ARITMETICOS
+ | - | * | / | MODULO | EXP(BASE,EXPOENTE)

MESSAGE iNum + iNum2 VIEW-AS ALERT-BOX.
MESSAGE iNum - iNum2 VIEW-AS ALERT-BOX.
MESSAGE iNum * iNum2 VIEW-AS ALERT-BOX.
MESSAGE iNum / iNum2 VIEW-AS ALERT-BOX.
MESSAGE iNum MODULO iNum2 VIEW-AS ALERT-BOX.
MESSAGE EXP(iNum, iNum2) VIEW-AS ALERT-BOX.

*RELACIONAIS
= | < | > | <>

MESSAGE iNum = iNum2 VIEW-AS ALERT-BOX.
MESSAGE iNum < iNum2 VIEW-AS ALERT-BOX.
MESSAGE iNum > iNum2 VIEW-AS ALERT-BOX.
MESSAGE iNum <> iNum2 VIEW-AS ALERT-BOX.

//MODULO - MOSTRA O RESTO DA DIVISÃO
//EXP - EPOENTE, EXP(BASE,EXPOENTE)
 
- OPERADORES LÓGICOS: 
AND | OR | NOT

DEF VAR lLG  AS LOGICAL INITIAL YES.
DEF VAR lLG2 AS LOGICAL INITIAL NO.

IF (lLG AND lLG2) THEN
DO:
MESSAGE "ENTREI" VIEW-AS ALERT-BOX TITLE "ENTREI".     
END.

IF lLG OR lLG2 THEN
DO:
MESSAGE "ENTREI2" VIEW-AS ALERT-BOX TITLE "ENTREI2".     
END.

IF NOT lLG2 THEN
DO:
MESSAGE "ENTREI3" VIEW-AS ALERT-BOX TITLE "ENTREI3".
END.

- ESTRUTURAS CONDICIONAIS

IF | ELSE | ELSE IF 

DEF VAR iDade AS INT INITIAL 17.

iDade = 60.

IF iDade < 18 THEN
DO:
  MESSAGE "MENOR DE IDADE" VIEW-AS ALERT-BOX.      
END.
ELSE IF iDade >= 18 AND iDade < 60 THEN
DO:
    MESSAGE "ADUTO" VIEW-AS ALERT-BOX.
END.
ELSE DO:   
    MESSAGE "IDOSO" VIEW-AS ALERT-BOX.
END.

| SWITCH CASE |

DEF VAR cStatus AS CHAR.

cStatus = "A".

CASE cStatus:
    WHEN "A" THEN
    DO:
       MESSAGE "ATIVO" VIEW-AS ALERT-BOX. 
    END.
    WHEN "I" THEN
    DO:
       MESSAGE "INATIVO" VIEW-AS ALERT-BOX.        
    END.
    OTHERWISE 
    DO:
       MESSAGE "NÃO APLICADO" VIEW-AS ALERT-BOX. 
    END.
END CASE.

- ESTRUTURA DE REPETIÇÃO 

| DO TO |

DEF VAR iCont AS INT INITIAL 1.
DEF VAR iNumCont AS INT.
DEF VAR iLog AS LOGICAL INITIAL NO.

DO iCont = 1 TO 10:
   iNumCont = iNUmCont + 1.
   IF iNumCont >= 1 THEN
   DO:
     IF iNumCont = 10 THEN
     DO:
        iLog = YES.
        iNumCont = 1.
        MESSAGE "REINICIOU" iLog VIEW-AS ALERT-BOX.
     END.
   END.
//conta ate 10 quando chega no 10 ele reinicia a contagem e sai    
END.

DO iCont = 1 TO 10 BY 2: //incrementa de 2 em 2, o BY server como um DE. 
   
END.

| TEMP-TABLE | CREATE .. ASSIGN | FOR EACH | --SELECT

DEF TEMP-TABLE cliente
   FIELD nome AS CHAR
   FIELD idade AS INT.
// TEMP-TABLE - CRIA TABELA TEMPORARIA   
// FIELD      - CRIA CAMPOS DA TABEL TEMP.

CREATE cliente.
ASSIGN cliente.nome = 'alisson'
       cliente.idade = 26.
//CREATE .. ASSIGN - FUNCIONA COMO UM INSERT DE REGISTRS NA TABELA TEMPORARIA.        
       
CREATE cliente.
ASSIGN cliente.nome = 'alisson'
       cliente.idade = 30.
  
CREATE cliente.
ASSIGN cliente.nome = 'alisson'
       cliente.idade = 35.
       
FOR EACH cliente WHERE cliente.idade > 30:
MESSAGE cliente.nome SKIP
        cliente.idade VIEW-AS ALERT-BOX. 
END.
//FOR EACH - FUNCIONA EXATAMENTE COMO UM SELECT, ELE FAZ UMA BUSCA EM UMA BANCO, EM UMA TABELA, EM REGISTROS...

| REPEAT |

NÃO SAI ATE QUE TENHA ALGUM CONTROLADOR DE FLUXO, É IGUAL UM WHILE .T. OU WHILE TRUE.

DEF VAR iCont AS INT.

REPEAT :
   iCont = iCont + 1.
   
    IF iCont > 5 THEN
    DO:
      LEAVE.  
    END.

END.

MESSAGE iCont VIEW-AS ALERT-BOX

- CONTROLES DE FLUXOS

| LEAVE | NEXT | RETURN |

DEF TEMP-TABLE cliente
   FIELD nome AS CHAR
   FIELD idade AS INT.

DEF VAR iCont AS INT.

DO iCont = 0 TO 5:
CREATE cliente.
ASSIGN cliente.nome = 'alisson'
       cliente.idade = 15 + iCont.       
END.       

RUN abc.

PROCEDURE abc:
    FOR EACH cliente :
    
        IF cliente.idade > 17 THEN
        DO:
            LEAVE.  //finaliza
            NEXT.   //passa para o proiimo registro
            RETURN. //vai sair do bloco principal, no caso o for each e a procedure. 
        END.
        
        MESSAGE cliente.nome SKIP
                cliente.idade VIEW-AS ALERT-BOX.
    END.
    
       MESSAGE "FIM DA EXECUÇÃO DO SISTEMA" VIEW-AS ALERT-BOX.
END PROCEDURE

- MANIPULAÇÃO DE BANCO 

* PESQUISAS
| FIND | -> | FIRST | LAST | NEXT | PREV

DEF VAR iCount AS INT.
        /*
 DO iCount = 0 TO 5:
     CREATE cliente.
        ASSIGN cliente.nome = 'ali'
                cliente.data_nasc = TODAY
                cliente.cpf = "13950194959"
                cliente.id = NEXT-VALUE(seq-id-cliente).
 END.
*/

FIND FIRST cliente. //achar o primeiro registro 

MESSAGE cliente.id VIEW-AS ALERT-BOX.

FIND LAST cliente. //achar o ultimo registro 

MESSAGE cliente.id VIEW-AS ALERT-BOX.

FIND NEXT cliente. //pega o proximo registro do mostrado  

MESSAGE cliente.id VIEW-AS ALERT-BOX.

FIND PREV cliente.  //pega o anterior do registro mostrado

MESSAGE cliente.id VIEW-AS ALERT-BOX

| NO-LOCK | EXCLUSIVE-LOCK |

FIND LAST cliente WHERE cliente.id = 24
                        AND client.data_nasc = TODAY NO-LOCK.
//EXCLUSIVE-LOCK: modificar um campo da tabela que esta no find travasse o registro
//NO-LOCK: Vai olhr/ver um registro
MESSAGE cliente.id VIEW-AS ALERT-BOX.

| NO-ERROR | AVAIL |

FIND LAST cliente WHERE cliente.nome = "aliSSON"
                        AND client.data_nasc = TODAY NO-ERROR.
                        
IF NOT AVAIL cliente THEN 
DO:
  MESSAGE "NÃO ENCONTRADO" VIEW-AS ALERT-BOX.  
END.
//AVAIL: verifica se o registro existe na memoria, no caso se o find conseguiu achar e guardou na memoria. 
//NO-ERRO: impede que o programa pare, caso alguma validação pare.

| FOR EACH | BREAK BY | -> DESCENDING

FOR EACH cliente WHERE cliente.id > 20 BREAK BY cliente.id DESCENDING:
    DISPLAY cliente.
END.

// BREAK BY -> Funciona como um order by, ex: Break By cliente.id. 
// DESCENDING-> Funciona como um DEC, usado para ver de forma decrescente.
// FOR EACH -> iual a um select, funciona para fazer pesquisas no banco. 

* ATUALIZAÇÃO 
| ASSIGN | UPDATE |

FIND LAST client.

//ASSIGN cliente.nome = 'Gabriel'
//UPDATE cliente.nome 

MESSAGE cliente.nome VIEW-AS ALERT-BOX.

//ASSIGN -> Aribui o valor novo de forma direta.
//UPDATE -> Abre um display para voce trocar a mão o registro necessario. 

* EXCLUSÃO 

| DELETE |

FIND LAST cliente. 

DELETE cliente. 

//DELETE -> Nesse caso apaga o ultimo registro da minha tabela. 

| BUFFER |

DEF BUFFER bff-cliente FOR cliente. 

FOR EACH cliente:
     FIND FIRST bff-cliente.
     
END.

//BUFFER -> Usado quando a tabela esta inacessivel por algum comando que ja esteja em pesquisa, dai voce da um alias e puxa ele no find, ou o que for. 

| TEMP-TABLE ... LIKE ... | BUFFER-COPY ... TO ... |

DEF TEMP-TABLE tt-cliente LIKE cliente. 
          /*         
CREATE tt-cliente. 
    ASSIGN tt-cliente.nome = 'ali'
            tt-cliente.id = NEXT-VALUE(seq01)
            tt-cliente.data_nasc = TODAY
            tt-cliente.cpf = '13950194959'
        */          
                
BUFFER-COPY tt-cliente TO cliente.
//copia os dados da tt-cliente para a cliente

//TEMP-TABLE TO -> Fa uma copia de uma tabela, no caso pega os campos
//BUFFER-COPY -> Faz a copi de registros de uma tabela para a outra.
OBS -> como se fosse faço na tabela temporaria depois jogo para a original. 

- FUNÇÕES E PROCEDURES

* FUNÇÕES 

| FUNCTION |

FUNCTION soma RETURNS DECIMAL(INPUT a AS INT, INPUT b AS INT):

    DEF VAR RESULT AS DEC. 
    
    RESULT = a + b. 
    RETURN RESULT. 

END FUNCTION. 


DEF VAR d-total AS DEC. 

d-total = soma(10,20).

MESSAGE d-total VIEW-AS ALERT-BOX.

// FUNCTION -> uma função normal aonde tem que falar o que vai dar de retorno, e trazer o retorno ao final, tambem trazendo os parametros. 

* PROCEDURES
- Usada como estrutura que organiza os códigos, podendo volta uma ou mais variaveis. 
- Podendo criar procedures interna e externas. 

Ex:
PROCEDURE saudacao: //inicio procedure

    MESSAGE 'OLA'.

END PROCEDURE.

RUN saudacao // roda a procedure

-INTERNAS
| INPUT | 

PROCEDURE saudacao:

    DEF INPUT PARAMETER nome AS CHAR

    MESSAGE 'OLA' + nome VIEW-AS ALERT-BOX.

END PROCEDURE.

RUN saudacao(INPUT"Alisson")

-Um parâmetro de entrada é usado quando você passa um valor para a procedure usar, mas não espera que ela altere sua variável.

| OUTPUT |

PROCEDURE saudacao:

    DEF OUTPUT PARAMETER nome AS CHAR.

    nome = 'Alisson'.

END PROCEDURE.

DEF VAR cmen AS CHAR.

RUN saudacao(OUTPUT cmen).

MESSAGE 'ola '+ cmen VIEW-AS ALERT-BOX.

- Um parâmetro de saída é usado quando a procedure devolve um valor para quem chamou. Ou seja, você passa uma variável vazia e a procedure preenche com algum valor.

| INPUT-OUTPUT |

PROCEDURE atua:

    DEF INPUT-OUTPUT PARAMETER valor AS DEC.
    DEF VAR iImp AS INT INITIAL 10.
    
    ASSIGN valor *= 2.
    
    ASSIGN valor += (valor*(iImp/100)).
END PROCEDURE.

DEF VAR valor-final AS DEC INITIAL 100.

RUN atua(INPUT-OUTPUT valor-final)

MESSAGE valor-final VIEW-AS ALERT-BOX

-EXTERNAS

* Basicamente são procedures que da de pegar de fora do arquivo, como se fosse uma user function mesmo. 
* nesse caso usasse o INPUT-OUTPUT, so que formulando que a procedure vai ser puxada de algum outro arquivo

ferramenta: PROTOOLS -> PROPATH

Nessa ferramenta voce consegue tirar o caminho absoluto , deixando so o arquivo que voce quer, no caso voce seta a pasta que irá ficar e automaticamente ele ira buscar no propath, se aquele arquivo existe em alguma das pastas setadas. 

- ARQUIVO 01: 

PROCEDURE atua:

    DEF INPUT-OUTPUT PARAMETER valor AS DEC.
    DEF VAR iImp AS INT INITIAL 10.
    
    RUN multi-2.p(INPUT-OUTPUT valor).
    
    ASSIGN valor +=(valor*(iImp/100)).
    
END PROCEDURE.

DEF VAR valor-final AS DEC INITIAL 100.

RUN atua(INPUT-OUTPUT valor-final)

MESSAGE valor-final VIEW-AS ALERT-BOX

- ARQUIVO 02:

DEF INPUT-OUTPUT PARAMETER valor AS DEC.

valor *= 2.

- TRANSAÇÕES E TRATAMENTO DE ERROS. 

* TRANSAÇÕES

| DO TRANSACTION | -> | UNDO |

- Usado para começar uma transação e se tiver algo acabar com ela com o UNDO. OBS: funciona como um begin transaction e rollback.

DEF VAR iValor AS INT. 

bloco:
DO TRANSACTION:
    
    ASSIGN iValor = 9.
    
    IF iValor >= 9 THEN
    DO:
         MESSAGE '>= 9' VIEW-AS ALERT-BOX.
         UNDO bloco, LEAVE bloco.
    END.    
END.

MESSAGE iValor VIEW-AS ALERT-BOX.

| NO-UNDO |

-Colocado na variavel, não fazendo ela se desfazer por conta do UNDO. 

DEF VAR iValor AS INT NO-UNDO. 

* TRATAMENTO DE ERRO

| ERROR-STATUS:ERROR | ERROR-STATUS:GET-MESSAGE(1) |
 
DEF TEMP-TABLE tt-cliente
    FIELD id AS INT.
    
bloco:
DO TRANSACTION:

    CREATE tt-cliente.
            ASSIGN tt-cliente.id = 2.
            
    FIND FIRST tt-cliente WHERE tt-cliente.id = 123 NO-ERROR.
    
    IF ERROR-STATUS:ERROR THEN
    DO:
        MESSAGE 'erro sistema' ERROR-STATUS:GET-MESSAGE(1) VIEW-AS ALERT-BOX.
        UNDO bloco, LEAVE bloco. 
    END.
END. 
 
FIND FIRST tt-cliente.

- ERROR-STATUS -> guarda infos do ultimo erro que deu.
- NO-ERROR -> Não aparece erro na tela, deixa eu tratar manualmente. 
- ...:ERROR -> Ele pergunta se houve algum erro no comando anterior, se sim retorna YES, se não retorna NO. 
- ...:GET-MESSAGE(1) -> Se o :ERROR, trouxer verdadeiro voce pode pegar a mensagem de erro.

| FILE-INFO:FILE-NAME | FILE-INFO:FULL-PATHNAME | 

DEF VAR cArquivo AS CHAR. 

cArquivo = "C:\Porgress-procedures\multi-2.p".

FILE-INFO:FILE-NAME = cArquivo.

IF FILE-INFO:FULL-PATHNAME = ? THEN
DO:
    MESSAGE "arquivo nao encontrado" VIEW-AS ALERT-BOX.
END.
ELSE DO:
    MESSAGE 'arquivo encontrado' VIEW-AS ALERT-BOX. 
END.

//? -> Desconhecido, ou valor não existente. 
//FILE-INFO:FILE-NAME -> Guarda o cainh do arquivo para comparar depois.
//...:FULL-PATHNAME -> traz o caminh inteiro do que foi passado.


